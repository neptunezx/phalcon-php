<?php

namespace Phalcon;

use Phalcon\DiInterface;
use Phalcon\Security\Random;
use Phalcon\Security\Exception;
use Phalcon\Di\InjectionAwareInterface;
use Phalcon\Session\AdapterInterface as SessionInterface;

/**
 * Phalcon\Security
 *
 * This component provides a set of functions to improve the security in Phalcon applications
 *
 * <code>
 *  $login = $this->request->getPost('login');
 *  $password = $this->request->getPost('password');
 *
 *  $user = Users::findFirstByLogin($login);
 *  if ($user) {
 *      if ($this->security->checkHash($password, $user->password)) {
 *          //The password is valid
 *      }
 *  }
 * </code>
 *
 * @see https://github.com/phalcon/cphalcon/blob/1.2.6/ext/security.c
 */
class Security implements InjectionAwareInterface
{

    /**
     * Dependency Injector
     *
     * @var null|\Phalcon\DiInterface
     * @var protected
     */
    protected $_dependencyInjector;

    /**
     * Work Factor
     *
     * @var int
     * @access protected
     */
    protected $_workFactor = 8;

    /**
     * Number of Bytes
     *
     * @var int
     * @access protected
     */
    protected $_numberBytes         = 16;
    protected $_tokenKeySessionID   = '$PHALCON/CSRF/KEY$';
    protected $_tokenValueSessionID = '$PHALCON/CSRF$';
    protected $_token;
    protected $_tokenKey;
    protected $_random;
    protected $_defaultHash;

    const CRYPT_DEFAULT    = 0;
    const CRYPT_STD_DES    = 1;
    const CRYPT_EXT_DES    = 2;
    const CRYPT_MD5        = 3;
    const CRYPT_BLOWFISH   = 4;
    const CRYPT_BLOWFISH_A = 5;
    const CRYPT_BLOWFISH_X = 6;
    const CRYPT_BLOWFISH_Y = 7;
    const CRYPT_SHA256     = 8;
    const CRYPT_SHA512     = 9;

    /**
     * Phalcon\Security constructor
     */
    public function __construct()
    {
        $this->_random = new Random();
    }

    /**
     * Sets the dependency injector
     *
     * @param \Phalcon\DiInterface $dependencyInjector
     * @throws FlashException
     */
    public function setDI($dependencyInjector)
    {
        if (is_object($dependencyInjector) === false ||
            $dependencyInjector instanceof DiInterface === false) {
            throw new FlashException('Invalid parameter type.');
        }

        $this->_dependencyInjector = $dependencyInjector;
    }

    /**
     * Returns the internal dependency injector
     *
     * @return \Phalcon\DiInterface|null
     */
    public function getDI()
    {
        return $this->_dependencyInjector;
    }

    /**
     * Sets a number of bytes to be generated by the openssl pseudo random generator
     *
     * @param $randomBytes int
     * @throws
     */
    public function setRandomBytes($randomBytes)
    {
        if (is_int($randomBytes) === false) {
            throw new FlashException('Invalid parameter type.');
        }
        $this->_numberBytes = $randomBytes;
    }

    /**
     * Returns a number of bytes to be generated by the openssl pseudo random generator
     *
     * @return int
     */
    public function getRandomBytes()
    {
        return $this->_numberBytes;
    }

    /**
     * Returns a secure random number generator instance
     * @return object
     */
    public function getRandom()
    {
        return $this->_random;
    }

    /**
     * Generate a >22-length pseudo random string to be used as salt for passwords
     * @param $numberBytes int
     * @return string
     */
    public function getSaltBytes($numberBytes = 0)
    {
        $safeBytes = null;
        if (!isset($numberBytes)) {
            $numberBytes = (int) $this->_numberBytes;
        }

        while (true) {
            $safeBytes = $this->_random->base64Safe($numberBytes);
            if (empty($safeBytes) || (strlen($safeBytes) < $numberBytes)) {
                continue;
            }
            break;
        }
        return $safeBytes;
    }

    /**
     * Creates a password hash using bcrypt with a pseudo random salt
     * @param $password string
     * @param $workFactor int
     * @return string
     * @throws
     */
    public function hash($password, $workFactor = 0)
    {
        if ($workFactor) {
            $workFactor = (int) ($this->_workFactor);
        }

        $hash = (int) ($this->_defaultHash);
        switch ($hash) {
            case self::CRYPT_BLOWFISH_A:
                $variant = "a";
                break;

            case self::CRYPT_BLOWFISH_X:
                $variant = "x";
                break;

            case self::CRYPT_BLOWFISH_Y:
                $variant = "y";
                break;

            case self::CRYPT_MD5:
                $variant = "1";
                break;

            case self::CRYPT_SHA256:
                $variant = "5";
                break;

            case self::CRYPT_SHA512:
                $variant = "6";
                break;

            case self::CRYPT_DEFAULT:
            default:
                $variant = "y";
                break;
        }

        switch ($hash) {
            case self::CRYPT_STD_DES:
            case self::CRYPT_EXT_DES:
                if ($hash == self::CRYPT_EXT_DES) {
                    $saltBytes = "_" . $this->getSaltBytes(8);
                } else {
                    $saltBytes = $this->getSaltBytes(2);
                }
                if (is_string($saltBytes) === false) {
                    throw new Exception("Unable to get random bytes for the salt");
                }
                return crypt($password, $saltBytes);
            case self::CRYPT_MD5:
            case self::CRYPT_SHA256:
            case self::CRYPT_SHA512:
                $saltBytes = $this->getSaltBytes($hash == self::CRYPT_MD5 ? 12 : 16);
                if (is_string($saltBytes) === false) {
                    throw new Exception("Unable to get random bytes for the salt");
                }
                return crypt($password, "$" . $variant . "$" . $saltBytes . "$");
            case self::CRYPT_DEFAULT:
            case self::CRYPT_BLOWFISH:
            case self::CRYPT_BLOWFISH_X:
            case self::CRYPT_BLOWFISH_Y:
            default:
                $saltBytes = $this->getSaltBytes(22);
                if (is_string($saltBytes) === false) {
                    throw new Exception("Unable to get random bytes for the salt");
                }

                if ($workFactor < 4) {
                    $workFactor = 4;
                } else {
                    if ($workFactor > 31) {
                        $workFactor = 31;
                    }
                }

                return crypt($password, "$2" . $variant . "$" . sprintf("%02s", $workFactor) . "$" . $saltBytes . "$");
        }
        return "";
    }

    /**
     * Checks a plain text password and its hash version to check if the password matches
     * @param $password  string
     * @param $passwordHash string
     * @param $maxPassLength int
     * @return boolean
     */
    public function checkHash($password, $passwordHash, $maxPassLength = 0)
    {
        if ($maxPassLength) {
            if ($maxPassLength > 0 && (strlen($password) > $maxPassLength)) {
                return false;
            }
        }

        $cryptedHash = (string) (crypt($password, $passwordHash));

        $cryptedLength  = strlen($cryptedHash);
        $passwordLength = strlen($passwordHash);
        $cryptedHash    .= $passwordHash;

        $sum = $cryptedLength - $passwordLength;
        for ($i = 0; $i < strlen($passwordHash); $i++) {
            $ch  = ord($passwordHash[$i]);
            $sum = $sum | ( ord($cryptedHash[$i]) ^ $ch);
        }
        return 0 === $sum;
    }

    /**
     * Checks if a password hash is a valid bcrypt's hash
     * @param $passwordHash string
     * @return boolean
     */
    public function isLegacyHash($passwordHash)
    {
        return starts_with($passwordHash, "$2a$");
    }

    /**
     * Generates a pseudo random token key to be used as input's name in a CSRF check
     * @return string
     * @throws
     */
    public function getTokenKey()
    {
        if (null === $this->_tokenKey) {
            $dependencyInjector = $this->_dependencyInjector;
            if (!is_object($dependencyInjector)) {
                throw new Exception("A dependency injection container is required to access the 'session' service");
            }

            $this->_tokenKey = $this->_random->base64Safe($this->_numberBytes);
            $session         = $dependencyInjector->getShared("session");
            $session->set($this->_tokenKeySessionID, $this->_tokenKey);
        }
        return $this->_tokenKey;
    }

    /**
     * Generates a pseudo random token value to be used as input's value in a CSRF check
     * @return string
     * @throws
     */
    public function getToken()
    {
        if (null === $this->_token) {
            $this->_token = $this->_random->base64Safe($this->_numberBytes);

            $dependencyInjector = $this->_dependencyInjector;

            if (!is_object($dependencyInjector)) {
                throw new Exception("A dependency injection container is required to access the 'session' service");
            }

            $session = $dependencyInjector->getShared("session");
            $session->set($this->_tokenValueSessionID, $this->_token);
        }

        return $this->_token;
    }

    /**
     * Check if the CSRF token sent in the request is the same that the current in session
     * @param $tokenKey null
     * @param $tokenValue null
     * @param $destroyIfValid boolean
     * @return boolean
     * @throws
     */
    public function checkToken($tokenKey = null, $tokenValue = null, $destroyIfValid = true)
    {
        $dependencyInjector = $this->_dependencyInjector;

        if (!is_object($dependencyInjector)) {
            throw new Exception("A dependency injection container is required to access the 'session' service");
        }

        $session = $dependencyInjector->getShared("session");

        if (!$tokenKey) {
            $tokenKey = $session->get($this->_tokenKeySessionID);
        }

        if (!$tokenKey) {
            return false;
        }

        if (!$tokenValue) {
            $request   = $dependencyInjector->getShared("request");
            $userToken = $request->getPost($tokenKey);
        } else {
            $userToken = $tokenValue;
        }
        $knownToken = $session->get($this->_tokenValueSessionID);
        $equals     = hash_equals($knownToken, isset($userToken) ? $userToken : "");

        if ($equals && $destroyIfValid) {
            $this->destroyToken();
        }
        return $equals;
    }

    /**
     * Returns the value of the CSRF token in session
     * @return string
     * @throws
     */
    public function getSessionToken()
    {
        $dependencyInjector = $this->_dependencyInjector;

        if (!is_object($dependencyInjector)) {
            throw new Exception("A dependency injection container is required to access the 'session' service");
        }
        $session = $dependencyInjector->getShared("session");
        return $session->get($this->_tokenValueSessionID);
    }

    /**
     * Removes the value of the CSRF token and key from session
     * @return object
     * @throws
     */
    public function destroyToken()
    {
        $dependencyInjector = $this->_dependencyInjector;
        if (!is_object($dependencyInjector)) {
            throw new Exception("A dependency injection container is required to access the 'session' service");
        }
        $session         = $dependencyInjector->getShared("session");
        $session->remove($this->_tokenKeySessionID);
        $session->remove($this->_tokenValueSessionID);
        $this->_token    = null;
        $this->_tokenKey = null;
        return $this;
    }

    /**
     * Computes a HMAC
     * @param $data string
     * @param $key string
     * @param $algo string
     * @param $raw bool
     * @return string
     * @throws
     */
    public function computeHmac($data, $key, $algo, $raw = false)
    {
        $hmac = hash_hmac($algo, $data, $key, $raw);
        if (!$hmac) {
            throw new Exception("Unknown hashing algorithm: %s" . algo);
        }
        return $hmac;
    }

    /**
     * Sets the default hash
     * @param $defaultHash
     * @return object
     */
    public function setDefaultHash($defaultHash)
    {
        $this->_defaultHash = $defaultHash;
        return $this;
    }

    /**
     * Returns the default hash
     * @return int|null
     */
    public function getDefaultHash()
    {
        return $this->_defaultHash;
    }

    /**
     * Testing for LibreSSL
     *
     * @deprecated Will be removed in 4.0.0
     * @return bool
     */
    public function hasLibreSsl()
    {
        if (!defined("OPENSSL_VERSION_TEXT")) {
            return false;
        }
        return strpos(OPENSSL_VERSION_TEXT, "LibreSSL") === 0;
    }

    /**
     * Getting OpenSSL or LibreSSL version.
     *
     * Parse OPENSSL_VERSION_TEXT because OPENSSL_VERSION_NUMBER is no use for LibreSSL.
     * This constant show not the current system openssl library version but version PHP was compiled with.
     *
     * @deprecated Will be removed in 4.0.0
     * @link https://bugs.php.net/bug.php?id=71143
     *
     * <code>
     * if ($security->getSslVersionNumber() >= 20105) {
     *     // ...
     * }
     * </code>
     * @return int
     * @throws
     */
    public function getSslVersionNumber()
    {
        if (!defined("OPENSSL_VERSION_TEXT")) {
            return 0;
        }

        preg_match("#(?:Libre|Open)SSL ([\d]+)\.([\d]+)(?:\.([\d]+))?#", OPENSSL_VERSION_TEXT, $matches);

        if (!isset($matches[2])) {
            return 0;
        }

        $major = (int) ($matches[1]);
        $minor = (int) ($matches[2]);

        if (isset($matches[3])) {
            $patch = (int) ($matches[3]);
        }

        return 10000 * $major + 100 * $minor + $patch;
    }

}
